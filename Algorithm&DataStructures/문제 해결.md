# 문제해결

## 접근법

1. 문제 이해
   - 문제를 명확히 하고 각 상황에서 어떻게 처리할지에 대한 고민
2. 구체적인 예시
   - 입력값, 출력값, 에러 등을 어떻게 처리할지에 대한 고민
3. 세분화
   - 구현해야할 코드에 대한 틀을 잡기 위한 단계를 세분화(주석 이용)
   - 코드를 무작정 작성하기 보다는 코드의 방향성을 확실히 결정
4. 해결 또는 단순화
   - 해결할 수 있는 문제부터 처리하고, 어려운 부분은 해결책을 주석으로 작성하고 나중에 연결
5. 리팩터링

## 패턴

### 1. 빈도 카운터(Frequency Counter)

첫번째 예제와 같이 중첩 반복문을 사용할 경우 O(n^2)이 된다. 두번째 예제처럼 문자의 빈도수 객체를 만들면 단일 반복문으로 비교가 가능하다. 이럴 경우에는 O(n)이 된다.

```jsx
// 순수 접근법
function same(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (let i = 0; i < arr1.length; i++) {
    let correctIndex = arr2.indexOf(arr1[i] ** 2);
    if (correctIndex === -1) {
      return false;
    }
    console.log(arr2);
    arr2.splice(correctIndex, 1);
  }
  return true;
}

same([1, 2, 3, 2], [9, 1, 4, 4]);
```

```jsx
// 빈도 카운터
function same(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  let frequencyCounter1 = {};
  let frequencyCounter2 = {};
  for (let val of arr1) {
    frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1;
  }
  for (let val of arr2) {
    frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1;
  }
  console.log(frequencyCounter1);
  console.log(frequencyCounter2);
  for (let key in frequencyCounter1) {
    if (!(key ** 2 in frequencyCounter2)) {
      return false;
    }
    if (frequencyCounter2[key ** 2] !== frequencyCounter1[key]) {
      return false;
    }
  }
  return true;
}

same([1, 2, 3, 2, 5], [9, 1, 4, 4, 11]);
```

### 2.

## 출처

[](https://www.udemy.com/course/best-javascript-data-structures/learn/lecture/28559683#overview)
